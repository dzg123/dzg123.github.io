<!DOCTYPE html>
<html lang="zh">
<head>
    <meta name="generator" content="Hugo 0.51">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no">
    <meta name="wap-font-scale" content="no">
    <meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34">
    <meta name="sogou_site_verification" content="E8uWFBcf4a">
    <meta name="author" content="dzg">
    <meta name="keywords" content="">
    <meta property="og:locale" content="en_US">
    <meta property="og:title" content=" dzg">
    <title>blog | dzg</title>
    <link rel="shortcut icon" href="/images/favicon.ico">
    <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <script src="/lib/highlight.min.js">
    </script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="/lib/jquery/jquery.min.js"></script>
    <script>
        document.addEventListener("error", function (e) {
            var elem = e.target;
            if (elem.tagName.toLowerCase() == 'img') {
                elem.style.display = 'none'
            }
        }, true);
    </script>
</head>
<body>
<div id="header-post">
    <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
    <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#"
                                                                              onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"
                                                                              style="display:none;"><i
        class="fa fa-chevron-up fa-lg"></i></a> <span
        id="menu"><span id="nav"><ul><li><a href="/">主页</a></li><li><a href="/blog/">博客</a></li><li><a
        href="/about/">关于我</a></li><li><a href="http://github.com/dzg123"
                                          target="_blank">Github</a></li></ul></span><br>

</span>
</div>
<div class="content index width mx-auto px3 my3">
    <section id="wrapper" class="home">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
            <header>
                <h1 class="posttitle" itemprop="name headline">Spring常见问题</h1>
                <div class="meta">
                    <div class="postdate">
                        <time datetime="2018-10-20" itemprop="datePublished">2019-08-18</time>
                    </div>
                    <div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span
                            id="busuanzi_value_page_pv">0</span></span></div>
                    <div class="article-tag"><i class="fa fa-tag"></i> <a href="/tags/spring">spring</a></div>
                    <div class="article-tag-box"></div>
                </div>
            </header>
            <!--markdown-->
            <p>转自：Java3y</p>
            <h2>2.1什么是spring?</h2>
            <blockquote><p>什么是spring?</p>
            </blockquote>
            <p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring框架<strong>目标是简化Java企业级应用开发</strong>，并通过POJO为基础的编程模型促进良好的编程习惯。</p>
            <h2>2.2使用Spring框架的好处是什么？</h2>
            <blockquote><p>使用Spring框架的好处是什么？</p>
            </blockquote>
            <ul>
                <li><strong>轻量</strong>：Spring 是轻量的，基本的版本大约2MB。</li>
                <li><strong>控制反转</strong>：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
                <li><strong>面向切面的编程</strong>(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
                <li><strong>容器</strong>：Spring 包含并管理应用中对象的生命周期和配置。</li>
                <li><strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
                <li><strong>事务管理</strong>：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li>
                <li><strong>异常处理</strong>：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>

            </ul>
            <h2>2.3Spring由哪些模块组成?</h2>
            <blockquote><p>Spring由哪些模块组成?</p>
            </blockquote>
            <p>简单可以分成6大模块：</p>
            <ul>
                <li>Core</li>
                <li>AOP</li>
                <li>ORM</li>
                <li>DAO</li>
                <li>Web</li>
                <li>Spring EE</li>

            </ul>
            <p><img src='https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib03XHfQ7GJx5IicSL37jAgtIeIOxr7kBnmHjnmdBvwHngJMT7IgcWeP0ZFLk9S7Sb8xY1kuLBYwL0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1' alt='img' referrerPolicy='no-referrer' /></p>
            <h2>2.4BeanFactory 实现举例</h2>
            <blockquote><p>BeanFactory 实现举例</p>
            </blockquote>
            <p>Bean工厂是工厂模式的一个实现，提供了控制反转功能，<strong>用来把应用的配置和依赖从正真的应用代码中分离</strong>。</p>
            <p>在spring3.2之前最常用的是XmlBeanFactory的，但现在被废弃了，取而代之的是：XmlBeanDefinitionReader和DefaultListableBeanFactory</p>
            <h2>2.5什么是Spring的依赖注入？</h2>
            <blockquote><p>什么是Spring的依赖注入？</p>
            </blockquote>
            <p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你<strong>不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务</strong>，之后一个容器（IOC容器）负责把他们组装起来。</p>
            <h2>2.6有哪些不同类型的IOC（依赖注入）方式？</h2>
            <blockquote><p>有哪些不同类型的IOC（依赖注入）方式？</p>
            </blockquote>
            <ul>
                <li><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li>
                <li><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li>
                <li>工厂注入：这个是遗留下来的，很少用的了！</li>

            </ul>
            <h2>2.7哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</h2>
            <blockquote><p>哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</p>
            </blockquote>
            <p>你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是<strong>用构造器参数实现强制依赖，setter方法实现可选依赖</strong>。</p>
            <h2>2.8什么是Spring beans?</h2>
            <blockquote><p>什么是Spring beans?</p>
            </blockquote>
            <p>Spring beans 是那些<strong>形成Spring应用的主干的java对象</strong>。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<code>&lt;bean/&gt;</code>的形式定义。</p>
            <p>这里有四种重要的方法给Spring容器<strong>提供配置元数据</strong>。</p>
            <ul>
                <li>XML配置文件。</li>
                <li>基于注解的配置。</li>
                <li>基于java的配置。</li>
                <li>Groovy DSL配置</li>

            </ul>
            <h2>2.9解释Spring框架中bean的生命周期</h2>
            <blockquote><p>解释Spring框架中bean的生命周期</p>
            </blockquote>
            <ul>
                <li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li>
                <li>Spring根据bean的定义填充所有的属性。</li>
                <li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li>
                <li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li>
                <li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li>
                <li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li>
                <li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li>
                <li>如果bean实现了 DisposableBean，它将调用destroy()方法。</li>

            </ul>
            <h2>2.10解释不同方式的自动装配</h2>
            <blockquote><p>解释不同方式的自动装配</p>
            </blockquote>
            <ul>
                <li>no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</li>
                <li>byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li>
                <li>byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li>
                <li>constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li>
                <li>autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li>

            </ul>
            <p>只用注解的方式时，<strong>注解默认是使用byType的</strong>！</p>
            <h2>2.11IOC的优点是什么？</h2>
            <blockquote><p>IOC的优点是什么？</p>
            </blockquote>
            <p>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。<strong>最小的代价和最小的侵入性使松散耦合得以实现</strong>。IOC容器支持加载服务时的<strong>饿汉式初始化和懒加载</strong>。</p>
            <h2>2.12哪些是重要的bean生命周期方法？ 你能重载它们吗？</h2>
            <blockquote><p>哪些是重要的bean生命周期方法？ 你能重载它们吗？</p>
            </blockquote>
            <p>有两个重要的bean 生命周期方法，第一个是<code>setup</code>， 它是在容器加载bean的时候被调用。第二个方法是 <code>teardown</code> 它是在容器卸载类的时候被调用。</p>
            <p>The bean 标签有两个重要的属性（<code>init<span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>method</code>和<code>destroy<span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>method</code>）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（<code>@PostConstruct</code>和<code>@PreDestroy</code>）。</p>
            <h2>2.13怎么回答面试官：你对Spring的理解？</h2>
            <blockquote><p>怎么回答面试官：你对Spring的理解？</p>
            </blockquote>
            <p>来源：</p>
            <ul>
                <li><a href='https://www.zhihu.com/question/48427693?sort=created' target='_blank' class='url'>https://www.zhihu.com/question/48427693?sort=created</a></li>

            </ul>
            <p>下面我就截几个答案：</p>
            <p>一、</p>
            <p><img src='https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib03XHfQ7GJx5IicSL37jAgtIwbz2TkS4qFJics9lfL9EHK38du1yDZg4yZht0CfU2TRyu6sO2Cl96hQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1' alt='img' referrerPolicy='no-referrer' /></p>
            <p>二、</p>
            <p><img src='https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib03XHfQ7GJx5IicSL37jAgtIibTVFtskTicQUJVGjKwMO83YhTsqGzDbyrCx4tOEP7ErKUGR1DEHyT8Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1' alt='img' referrerPolicy='no-referrer' /></p>
            <h2>2.14Spring框架中的单例Beans是线程安全的么？</h2>
            <blockquote><p>Spring框架中的单例Beans是线程安全的么？</p>
            </blockquote>
            <p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。<strong>如果你的bean有多种状态的话</strong>（比如 View Model 对象），就<strong>需要自行保证线程安全</strong>。</p>
            <p>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”</p>
            <h2>2.15FileSystemResource和ClassPathResource有何区别？</h2>
            <blockquote><p>FileSystemResource和ClassPathResource有何区别？</p>
            </blockquote>
            <p>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource文件放在ClassPath下。</p>
            <p>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</p>
            <p>简而言之，<strong>ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件</strong>。</p>

        </article>
        <script src="/js/av-min.js"></script>
        <script src="/js/Valine.min.js"></script>
        <div class="blog-post-comments"></div>
        <script>new Valine({
            el: '.blog-post-comments',
            app_id: '4pa6G5f3p9sLCmmqRgPTN8Qg-gzGzoHsz',
            app_key: 'xlVmYRcq8N3Feir3eh5SXUuu',
            placeholder: '说点什么?',
            avatar: 'robohash',
            notify: true,
            verify: true
        });</script>
    </section>
</div>
<footer id="footer">
    <div class="footer-left">Email © shzzjut@163.com
    </div>
    <div class="footer-right">
        <nav>
            <ul>
                <li><a href="/">主页</a></li>
                <li><a href="/blog/">博客</a></li>
                <li><a href="/about/">关于我</a></li>
                <li><a href="http://github.com/dzg123" target="_blank">Github</a></li>
            </ul>
        </nav>
    </div>
</footer>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/lib/typed.js"></script>
<script src="/js/main.js"></script>
<script async src=""></script>
<script>(function () {
    var imgArr = document.getElementsByTagName("img");
    for (var i = 0; i < imgArr.length; i++) {
        if (imgArr[i].width > 600) {
            var radio = imgArr[i].width / imgArr[i].height;
            imgArr[i].width = 600;
            imgArr[i].height = 600 / radio;
        }
        if (imgArr[i].height > 400) {
             radio = imgArr[i].width / imgArr[i].height;
            imgArr[i].height = 400;
            imgArr[i].width = 400 * radio;
        }
    }
    var ga = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(ga, s);
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());

    gtag('config', 'UA-129382678-1');
})()</script>
<script>(function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();</script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js?t=1540207086409')
            .then(function () {
                console.log('ServiceWorker Register Successfully.')
            })
            .catch(function (e) {
                console.error(e)
            });
    }
</script>
</body>
</html>